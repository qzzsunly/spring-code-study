# 自定义命名空间解析

当我们想要扩展Spring 的配置时，可以定义我们自己的标签，然后解析成 bean定义，注册到Spring 容器中。这时需要用到 `NamespaceHandler`。Spring 框架中除了beans顶级标签外，其他的顶级标签都是自定义命名空间中的标签。如，`p`、 `c`、`util`命名空间。

## `NamespaceHandler` 命名空间解析器

Spring 框架中`mvc`、`context`、`tx` 等功能都是通过扩展这个接口来实现的。这个接口负责将标签解析成bean 定义对象。该接口提供了`parse` 和`decorate` 方法。`parse`方法用来将顶级标签解析成`BeanDefinition`对象。`decorate` 方法负责对`parse`出来的`BeanDefinition`进行进一步处理，需要解析的可以是元素属性和标签。 可以返回原来的`BeanDefinition`，或者返回一个新的`BeanDefinition`。

为了解析的方便，Spring 提供了一个抽象类`NamespaceHandlerSupport`，封装了一些基础功能，并提供了两个新的接口(`BeanDefinitionParser`和`BeanDefinitionDecorator`)方便扩展。并提供了`registerBeanDefinitionDecorator`、`registerBeanDefinitionParser`、`registerBeanDefinitionDecoratorForAttribute`三个方法分别注册`BeanDefinitionParser`和`BeanDefinitionDecorator`实现类，内部用map来维护标签名或者属性名到`BeanDefinitionParser`和`BeanDefinitionDecorator`的映射关系，解析时用名称(无命名空间前缀)来查找。

## Spring提供的`NamespaceHandler`

Spring 提供了一些 `NamespaceHandler`来实现自身功能。下面详细了解一下。

### `SimplePropertyNamespaceHandler` 简单属性解析器

解析的命名空间为 `http://www.springframework.org/schema/p`。它将特定属性直接映射到bean属性。需要注意的重要一点是，`NamespaceHandler`无法预知所有可能的属性名。该实现类直接实现了`NamespaceHandler`。

下面是使用`NamespaceHandler`的一个例子: 

```xml
<bean id = "rob" class = "..TestBean" p:name="Rob" p:spouse-ref="sally"/>
```

这里的`p:name`直接对应于类`TestBean`上的`name`属性。`p:spouse-ref`属性对应于`spouse`属性，将`value `所对应的bean注入到该属性中。

`parse`方法直接记录日志信息，并返回 `null`。因为它只支持对属性进行解析。

```java
public BeanDefinition parse(Element element, ParserContext parserContext) {
		parserContext.getReaderContext().error(
				"Class [" + getClass().getName() + "] does not support custom elements.", element);
		return null;
	}
```

`decorate`将元素属性表示的属性设置到对应的对象属性中。每个属性都会调用一次这个方法。拿上文提到的例子来解释一下下面代码的逻辑。

```java
public BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definition, ParserContext parserContext) {
   if (node instanceof Attr) {
       //只处理标签属性
      Attr attr = (Attr) node;
       //获取到属性名称，例子中为 name
      String propertyName = parserContext.getDelegate().getLocalName(attr);
       //获取到属性值 例子中为 Rob
      String propertyValue = attr.getValue();
       //从当前bean定义取出属性值集合
      MutablePropertyValues pvs = definition.getBeanDefinition().getPropertyValues();
       //如果已经解析出了该属性，则记录一下错误日志。这里是因为我们可以用标签 <property> 来声明属性, p 标签实际上是一种简化形式。两种声明方式只能用一种来声明同一个属性
      if (pvs.contains(propertyName)) {
         parserContext.getReaderContext().error("Property '" + propertyName + "' is already defined using " +
               "both <property> and inline syntax. Only one approach may be used per property.", attr);
      }
       // 如果属性名以 _ref 结尾，则表示该属性值引用一个 bean ,_ref 前面是 bean 名称
      if (propertyName.endsWith(REF_SUFFIX)) {
         propertyName = propertyName.substring(0, propertyName.length() - REF_SUFFIX.length());
         // 将标签属性名转换成属性名，小写，破折号形式转成驼峰形式，值转换成 RuntimeBeanReference，这个对象会在运行时转成具体的bean
          pvs.add(Conventions.attributeNameToPropertyName(propertyName), new RuntimeBeanReference(propertyValue));
      }
      else {
          //字面值直接添加进去就行了
         pvs.add(Conventions.attributeNameToPropertyName(propertyName), propertyValue);
      }
   }
   return definition;
}
```

**小结：用这个自定义属性来替换`<property>`使用起来更方便。**

### `SimpleConstructorNamespaceHandler` 简单构造函数解析器

将自定义属性映射到构造函数参数。解析的命名空间地址为`http://www.springframework.org/schema/c`。需要注意该解析器无法预知所有的参数。

下面看一个简单例子：

```xml
<bean id="author" class="..TestBean" c:name="Enescu" c:work-ref="compositions"/>
```

将`name`映射到`TestBean`的构造函数`name`参数，值为`Enescu`，而`work`参数引用了`compositions` bean。

下面看一下源代码：

`parse` 方法不支持解析标签

```java
public BeanDefinition parse(Element element, ParserContext parserContext) {
   parserContext.getReaderContext().error(
         "Class [" + getClass().getName() + "] does not support custom elements.", element);
   return null;
}
```

`decorate` 方法， 每个参数都会调用一次这个方法：

```java
public BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definition, ParserContext parserContext) {
   if (node instanceof Attr) {
       //只解析标签属性
      Attr attr = (Attr) node;
       //获取参数名,上例中为 name
      String argName = StringUtils.trimWhitespace(parserContext.getDelegate().getLocalName(attr));
       // 获取参数值, Enescu
      String argValue = StringUtils.trimWhitespace(attr.getValue());

      ConstructorArgumentValues cvs = definition.getBeanDefinition().getConstructorArgumentValues();
      boolean ref = false;

      // handle -ref arguments
      if (argName.endsWith(REF_SUFFIX)) {
          //如果参数名以 -ref 结尾，获取到真正的参数名，work-ref 则为 work
         ref = true;
         argName = argName.substring(0, argName.length() - REF_SUFFIX.length());
      }

       // 如果是 引用， 则创建 RuntimeBeanReference，运行时动态解析为实际bean 
      ValueHolder valueHolder = new ValueHolder(ref ? new RuntimeBeanReference(argValue) : argValue);
      valueHolder.setSource(parserContext.getReaderContext().extractSource(attr));

      // handle "escaped"/"_" arguments
      if (argName.startsWith(DELIMITER_PREFIX)) {
         // 如果参数名以 _ 开头
         String arg = argName.substring(1).trim();

         // fast default check
         if (!StringUtils.hasText(arg)) {
             // 如果参数名为空，那么添加常规参数值
            cvs.addGenericArgumentValue(valueHolder);
         }
         // assume an index otherwise
         else {
             //解析通过构造函数参数下标来指定的参数
            int index = -1;
            try {
               index = Integer.parseInt(arg);
                //如果不是下标，则记录一下错误
            }
            catch (NumberFormatException ex) {
               parserContext.getReaderContext().error(
                     "Constructor argument '" + argName + "' specifies an invalid integer", attr);
            }
            if (index < 0) {
                // 下标小于0记录错误
               parserContext.getReaderContext().error(
                     "Constructor argument '" + argName + "' specifies a negative index", attr);
            }

            if (cvs.hasIndexedArgumentValue(index)) {
                //已经通过<constructor-arg>标签定义了
               parserContext.getReaderContext().error(
                     "Constructor argument '" + argName + "' with index "+ index+" already defined using <constructor-arg>." +
                     " Only one approach may be used per argument.", attr);
            }
			// 到这里则解析成功，添加进到ConstructorArgumentValues中去
            cvs.addIndexedArgumentValue(index, valueHolder);
         }
      }
      // no escaping -> ctr name
      else {
          // 不是下标形式，则直接转换参数名
         String name = Conventions.attributeNameToPropertyName(argName);
         if (containsArgWithName(name, cvs)) {
             //检查是否已经定义过
            parserContext.getReaderContext().error(
                  "Constructor argument '" + argName + "' already defined using <constructor-arg>." +
                  " Only one approach may be used per argument.", attr);
         }
         valueHolder.setName(Conventions.attributeNameToPropertyName(argName));
         cvs.addGenericArgumentValue(valueHolder);
      }
   }
   return definition;
}
```

#### 小结：配置构造函数的方式

1. 使用`<constructor-arg>`标签，可以使用名称来定义，也可以使用下标。

2. 在`<bean>`标签中使用`c:`自定义属性, 属性名有两种方式：

   1. 下标形式`_0` 
   2. 构造函数参数名形式`c:name="value"`

   如果参数值需要引用bean，那么需要在属性名后加上`_ref`表示引用。

两种方式对比：

| 方式                    | 名称                                     | 下标                                  |
| ----------------------- | ---------------------------------------- | ------------------------------------- |
| `<constructor-arg>`标签 | name=“name” value=“value” (ref=“beanid”) | index=“0” value=“value”(ref=“beanid”) |
| `c:`属性                | c: name=“value”(c:name_ref=“beanid”)     | c:\_0=“value” (c:_0_ref=“beanid”)     |
|                         |                                          |                                       |

###  `ContextNamespaceHandler`上下文命名空间解析器

